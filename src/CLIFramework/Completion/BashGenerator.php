<?php
namespace CLIFramework\Completion;
use CLIFramework\Buffer;
use Exception;
use CLIFramework\Application;
use CLIFramework\ArgInfo;

class BashGenerator
{
    public $app;

    /**
     * @var string $program
     */
    public $programName;

    /**
     * @var string $compName
     */
    public $compName;

    /**
     * @var string $bindName
     */
    public $bindName;

    public $buffer;

    public function __construct($app, $programName, $bindName, $compName)
    {
        $this->app = $app;
        $this->programName = $programName;
        $this->compName = $compName;
        $this->bindName = $bindName;
        $this->buffer = new Buffer;
    }

    public function output() {
        return $this->complete_application();
    }

    public function visible_commands(array $cmds) {
        $visible = array();
        foreach ($cmds as $name => $cmd) {
            if ( ! preg_match('#^_#', $name) ) {
                $visible[$name] = $cmd;
            }
        }
        return $visible;
    }

    public function render_argument_completion_values(ArgInfo $a) {
        if ($a->validValues || $a->suggestions) {
            $values = array();
            if ($a->validValues) {
                $values = $a->getValidValues();
            } elseif ($a->suggestions ) {
                $values = $a->getSuggestions();
            }
            return join(" ", $values);
        }
        return '';
    }

    public function complete_application() {
        $bindName = $this->bindName;
        $compName = $this->compName;

        $buf = new Buffer;
        $buf->appendLines(array(
            "# {$this->programName} bash completion script generated by CLIFramework",
            "# Web: http://github.com/c9s/php-CLIFramework",
            "# THIS IS AN AUTO-GENERATED FILE, PLEASE DON'T MODIFY THIS FILE DIRECTLY.",
        ));

        $completeMeta =<<<"BASH"
__complete_meta ()
{
    local app="{$this->programName}"
    local command_signature=\$1
    local complete_for=\$2
    local arg=\$3  # could be "--dir", 0 for argument index
    local complete_type=\$4

    # When completing argument valid values, we need to eval
    IFS=\$'\n' lines=(\$(\$app meta --bash \$command_signature \$complete_for \$arg \$complete_type))

    # Get the first line to return the compreply
    if [[ \${lines[0]} == "#groups" ]] ; then
        # groups means we need to eval
        output=\$(\$app meta --bash \$command_signature \$complete_for \$arg \$complete_type)
        eval "\$output"

        # Here we should get two array: "labels" and "descriptions"
        # But in bash, we can only complete words, so we will abandon the "descriptions"
        # We use "*" expansion because we want to expand the whole array inside the same string
        COMPREPLY=(\$(compgen -W "\${labels[*]}" -- \$cur))
    else
        # Complete the rest lines as words
        COMPREPLY=(\$(compgen -W "\${lines[*]:1}" -- \$cur))
    fi
}


BASH;
    $buf->append($completeMeta);



    $code =<<<'BASH'
__demo_main ()
{
    local cur words cword prev
    local command_signature
    _get_comp_words_by_ref -n =: cur words cword prev

    # Output application command alias mapping 
    # aliases[ alias ] = command
    declare -A subcommand_alias

    # Define the command names
    declare -A subcommands


    # option names defines the available options of this command
    declare -A options
    # options_require_value: defines the required completion type for each
    # option that requires a value.
    declare -A options_require_value

    # Command signature is used for fetching meta information from the meta command.
    command_signature="app"
    subcommand_alias=(["a"]="add" ["c"]="commit")
    subcommands=(["add"]="command to add" ["commit"]="command to commit")
    options=(["--debug"]=1 ["--verbose"]=1 ["--log-dir"]=1)
    options_require_value=(["--log-dir"]="__complete_directory")
    local argument_min_length=0

    # Get the command name chain of the current input, e.g.
    # 
    #     app asset install [arg1] [arg2] [arg3]
    #     app commit add
    #  
    # The subcommand dispatch should be done in the command complete function,
    # not in the root completion function. 
    # We should pass the argument index to the complete function.

    # command_index=1 start from the first argument, not the application name
    # Find the command position
    local command_index=1
    local argument_index=0
    local i
    local command
    local found_options=0
    while [ $command_index -lt $cword ]; do
        i="${words[command_index]}"
        case "$i" in
            # Ignore options
            --=*) found_options=1 ;;
            --*) found_options=1 ;;
            -*) found_options=1 ;;
            *)
                # looks like my command, that's break the loop and dispatch to the next complete function
                if [[ -n "$i" && -n "${subcommands[$i]}" ]] ; then
                    command="$i"
                    break
                elif [[ -n "$i" && -n "${subcommand_alias[$i]}" ]] ; then
                    command="$i"
                    break
                else
                    # If the command is not found, check if the previous argument is an option expecting a value
                    # or it's an argument

                    # the previous argument (might be)
                    p="${words[command_index-1]}"

                    # not an option value, push to the argument list
                    if [[ -z "${options_require_value[$p]}" ]] ; then
                        ((argument_index++))
                    fi
                fi
            ;;
        esac
        ((command_index++))
    done

    # If the first command name is not found, we do complete...
    if [[ -z "$command" ]] ; then
        case "$cur" in
            # If the current argument $cur looks like an option, then we should complete
            --*)
                __mycomp "${!options[*]}"
                return
            ;;
            *)
                # The argument here can be an option value. e.g. --output-dir /tmp
                # The the previous one...
                if [[ -n "$prev" && -n "${options_require_value[$prev]}" ]] ; then
                    # TODO: local complete_type="${options_require_value[$prev]"}
                    __complete_meta "app.commit" "opt" "c" "valid-values"
                else
                    # If the command requires at least $argument_min_length to run, we check the argument
                    if [[ $argument_min_length > 0 ]] ; then
                        __complete_meta "app.commit" "opt" "c" "valid-values"
                    else
                        # If there is no argument support, then user is supposed to give a subcommand name or an option
                        __mycomp "${!options[*]} ${!subcommands[*]} ${!subcommand_alias[*]}"
                    fi
                fi
                return
            ;;
        esac
    else
        # We just found the first command, we are going to dispatch the completion handler to the next level...
        # Rewrite command alias to command name to get the correct response
        if [[ -n "${subcommand_alias[$command]}" ]] ; then
            command="${subcommand_alias[$command]}"
        fi
        local completion_func="__demo_comp_${command//-/_}"

        # declare the completion function name and dispatch rest arguments to the complete function
        command_signature="${command_signature}.${command}"
        declare -f $completion_func >/dev/null && $completion_func $command_signature $command_index && return
    fi
}

complete -o bashdefault -o default -o nospace -F __demo_main $bindName 2>/dev/null
BASH;

        return $buf->__toString();
    }
}


